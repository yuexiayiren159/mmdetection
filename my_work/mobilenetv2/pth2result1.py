'''
import torch
pred_maps = [[1,255,9,13], [1,255,18,26],[1,255,36,52]]
featmap_sizes = [torch.Size([9, 13]), torch.Size([18, 26]), torch.Size([36, 52])]  
featmap_sizes = [pred_map.shape[-2:] for pred_map in pred_maps]

pred_maps[0] - > torch.Size([1, 255, 9, 13])
mlvl_anchors = self.prior_generator.grid_priors(
            featmap_sizes, device=pred_maps[0].device)

锚框（bboxes）和预测框（pred_bboxes）
(bboxes[..., :2] + bboxes[..., 2:]) * 0.5
bboxes[..., :2] 提取锚框的左上角 (x1, y1) 坐标。
bboxes[..., 2:] 提取锚框的右下角 (x2, y2) 坐标。
(bboxes[..., :2] + bboxes[..., 2:]) * 0.5 计算了锚框的中心点坐标 (cx, cy)。

(pred_bboxes[..., :2] - 0.5) * stride
pred_bboxes[..., :2] 提取预测的相对偏移量，这通常是通过 sigmoid 激活的
- 0.5 将 sigmoid 激活后的输出值从 [0, 1] 范围调整到 [-0.5, 0.5] 范围，这样可以表示偏移的方向。
* stride 将相对偏移转换到原图的尺度，因为特征图上的偏移量需要乘以步长（stride）才能映射回原始图像

举例说明
假设锚框的左上角和右下角坐标分别为 (100, 50) 和 (200, 150)，则：

锚框的中心点为 (150, 100)。
如果模型预测的偏移量为 (0.6, 0.4)，那么调整后的偏移量为 (0.6 - 0.5, 0.4 - 0.5) = (0.1, -0.1)。
假设步长 stride 为 32，那么在原始图像上的偏移量为 (0.1 * 32, -0.1 * 32) = (3.2, -3.2)。
调整后的中心点为 (150 + 3.2, 100 - 3.2) = (153.2, 96.8)。

bboxes[..., 2:] 提取的是基础框的右下角 (x2, y2) 坐标。
bboxes[..., :2] 提取的是基础框的左上角 (x1, y1) 坐标。
bboxes[..., 2:] - bboxes[..., :2] 计算了基础框的宽度和高度 (w, h)。

基础框的宽度和高度 (w, h) 被缩放到一半，即 (w/2, h/2)。这是因为后面计算中心点时是以宽高的一半为基础的。
pred_bboxes[..., 2:] 提取的是模型预测的相对宽高变化量，通常通过网络输出的最后两个通道给出。
pred_bboxes[..., 2:].exp() 通过指数函数将这些相对变化量转化为缩放因子。指数函数 exp() 是常用的操作，确保预测变化量是正的
得到解码后的宽度和高度:

将基础框的 (w/2, h/2) 与预测的缩放因子相乘，得到解码后的宽度和高度的一半。
最终，whs 变量包含了解码后的框的宽度和高度的一半。

举例说明
假设基础框的左上角和右下角坐标分别为 (100, 50) 和 (200, 150)，则：

基础框的宽度和高度为 (200 - 100, 150 - 50) = (100, 100)。
计算宽度和高度的一半：(100 / 2, 100 / 2) = (50, 50)。
如果模型预测的相对宽高变化量为 (0.1, 0.2)，则通过指数函数转化为缩放因子为 (exp(0.1), exp(0.2)) ≈ (1.105, 1.221)。
解码后的宽度和高度为 (50 * 1.105, 50 * 1.221) ≈ (55.25, 61.05)。
这些解码后的宽度和高度值是边界框尺寸调整的结果。

总结
whs 代表解码后的边界框的宽度和高度的一半。它通过将基础框的宽高与模型预测的相对变化量相结合，并通过指数函数计算得到。最终，这些值用于确定解码后的边界框的实际尺寸，与中心点坐标一起用于定位检测结果的边界框。

详细解释
模型输出的预测值通常包括以下几个部分：

中心点的相对偏移量：

表示相对于锚框中心点的偏移量。
边界框的相对缩放：

表示相对于锚框尺寸的缩放比例。
这些预测结果需要经过解码才能得到实际的边界框位置和尺寸。解码过程中的关键步骤之一是将预测的缩放系数应用到锚框的尺寸上，得出实际的边界框尺寸。

计算步骤
计算锚框的中心点：

center_x, center_y = (x1 + x2) / 2, (y1 + y2) / 2
计算锚框的宽度和高度：

width, height = x2 - x1, y2 - y1
计算预测的缩放比例：

模型输出的宽高变化量是对数空间的，通过指数函数 exp() 转换为实际的比例系数。假设模型输出为 tw, th，则宽度和高度的缩放系数为 exp(tw), exp(th)。
应用缩放系数：

通过锚框的尺寸和预测的缩放系数计算解码后的尺寸：
decoded_width = width * exp(tw)
decoded_height = height * exp(th)
在上述计算中，解码后的宽度和高度是基于锚框的宽度和高度的一半进行缩放的。这是因为在模型的预测阶段，通常使用的是中心点坐标加上偏移量来预测最终的边界框位置，而宽度和高度的预测是相对于锚框的中心点和边缘进行的。

为什么是一半
使用一半的宽度和高度来进行计算的主要原因是为了简化计算过程和保持计算的一致性。具体而言：

在预测过程中，边界框的预测通常是基于中心点坐标和相对尺寸变化的。为了计算解码后的边界框坐标，需要知道中心点的绝对位置以及相对于锚框尺寸的变化。
当使用相对变化量（例如预测的宽度和高度）时，这些变化量直接影响到边界框的两边。因此，最终计算出的 whs 代表解码后的宽度和高度的一半值，这样在确定实际边界框的左上角和右下角坐标时可以直接加减这一半值。
总结
在解码过程中，whs 代表解码后的边界框的宽度和高度的一半，这是因为边界框的预测和解码通常是基于中心点加上相对偏移量和缩放系数来实现的。通过使用宽度和高度的一半值，可以简化边界框的解码计算过程，并保持计算的一致性
xy_centers = (bboxes[..., :2] + bboxes[..., 2:]) * 0.5 + (
            pred_bboxes[..., :2] - 0.5) * stride



decoded_bboxes = torch.stack(
    (xy_centers[..., 0] - whs[..., 0],  # 左上角 x 坐标
     xy_centers[..., 1] - whs[..., 1],  # 左上角 y 坐标
     xy_centers[..., 0] + whs[..., 0],  # 右下角 x 坐标
     xy_centers[..., 1] + whs[..., 1]), # 右下角 y 坐标
    dim=-1)

decoded_bboxes = torch.stack(
    (xy_centers[..., 0] - whs[..., 0], xy_centers[..., 1] -
        whs[..., 1], xy_centers[..., 0] + whs[..., 0],
        xy_centers[..., 1] + whs[..., 1]),
    dim=-1)

decoded_bboxes = torch.Size([1, 7371, 4])



det_bboxes, keep_idxs = batched_nms(bboxes, results.scores,
                                    results.labels, cfg.nms)
                                    
'''